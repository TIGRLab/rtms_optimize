#!/usr/bin/env python
## Minimal test suite for validating tetrahedral projection algorithm
##
## Tests implemented:
##
##     1. Fully embedded tetrahedrons
##     2. Bordering sample rejection and resampling
##     3. Direction-specific dual membership
##     4. Single voxel exclusion test (2x2 voxels, planar, 1 voxel excluded)
##     5. Comparison to analytical solution for simple 2 voxel test
##


import os
import numpy as np
from fieldopt import tetrapro

import mock

def gen_fully_embedded_tet(n,shape):
    '''
    Generate <n> Class 1 (fully embedded) tetrahedrons within a data grid of shape <shape>
    Returns a list of coordinates for each node as well as vertex ID for each tetrahedron

    Implementational Details:
    For each tetrahedron, select a voxel i,j,k in linear ordering
    Generate a (4x3) matrix of uniformly distributed variables, where n=4 describes the number of vertices
        and m=3 describes the i,j,k coordinates respectively.

    Adjust columns of the random matrix according to voxel identity to ensure complete embedding of
    tetrahedral vertices in voxel i,j,k
    '''

    node_ids = np.ones((n,4),dtype=np.int).cumsum().reshape((n,4)) - 1
    coord_array = np.zeros((n*4,3))
    for i in np.arange(0,n):

        #Select voxel in shape
        step_z = i // (shape[0] * shape[1])
        step_y = i // (shape[0]) - shape[2]*step_z
        step_x = i - shape[1]*step_y - shape[1]*shape[2]*step_z
        selected_vox=(step_x,step_y,step_z)

        #Generate 4 sets of random integers within the boundaries defined by voxel
        rand_coords = np.random.random(size=(4,3))

        #Modify each value generated by boundariers defined by voxel
        rand_coords[:,0] += step_x
        rand_coords[:,1] += step_y
        rand_coords[:,2] += step_z

        coord_array[4*i,:] = rand_coords[0,:]
        coord_array[4*i+1,:] = rand_coords[1,:]
        coord_array[4*i+2,:] = rand_coords[2,:]
        coord_array[4*i+3,:] = rand_coords[3,:]

    return node_ids, coord_array.flatten()

def test_fully_embedded_tets_for_projection():
    '''
    Fully embedded tetrahedron test, full algorithm testing
    '''

    N = 10
    t = N**3
    affine = np.eye(4)
    data_grid = np.ones((N**3),dtype=np.int64).cumsum()
    data_grid = data_grid.reshape((N,N,N))
    data_grid = np.swapaxes(data_grid,0,2)

    node_list, coord_array = gen_fully_embedded_tet(t, data_grid.shape)
    estimates = tetrapro.tetrahedral_projection(node_list,coord_array,data_grid,affine)
    total_embedding_score = np.max(estimates,axis=0).sum()
    assert int(total_embedding_score) == t


def test_directional_membership_is_correct():
    '''
    Generate a 3x3x3 cube data grid then test memberships in the following order
    [-x, +x, -y, +y, -z, +z]
    '''

    #For each axis make two tetrahedrons
    updown = np.array([
        [0,1,2,3],
        [0,1,2,4]
        ])
    leftright = np.array([
        [0,1,2,3],
        [0,1,2,4]
        ])
    inout = np.array([
        [0,1,2,3],
        [0,1,2,4]
        ])

    #Make planar fixed coordinates for each pair
    c_updown = np.array([
        [1, 1.5, 2],
        [2, 1.5, 2],
        [1.5, 1.5, 1],
        [1.5, 0, 1.5], #top
        [1.5, 2.8, 1.5], #bottom
    ]).flatten()

    c_leftright = np.array([

        [1.5, 1, 2],
        [1.5, 2, 2],
        [1.5, 1.5, 1],
        [0, 1.5, 1.5], #left
        [2.8, 1.5, 1.5] #right
    ]).flatten()

    c_inout = np.array([

        [1, 2, 1.5],
        [2, 2, 1.5],
        [1.5, 1, 1.5],
        [1.5, 1.5, 0], #front
        [1.5, 1.5, 2.8] #back
    ]).flatten()

    #Make data grid and write values in testing region
    data_grid = np.zeros( (3,3,3), dtype=np.int64)

    #Central point
    data_grid[1,1,1] = 0

    #Test points
    data_grid[1,0,1] = 1 #top
    data_grid[1,2,1] = 2 #bottom
    data_grid[0,1,1] = 3 #left
    data_grid[2,1,1] = 4 #right
    data_grid[1,1,0] = 5 #front
    data_grid[1,1,2] = 6 #back

    #Basic affine
    affine = np.eye(4)

    #Run projection algorithm
    ud_est = tetrapro.tetrahedral_projection(updown, c_updown, data_grid, affine)
    lr_est = tetrapro.tetrahedral_projection(leftright, c_leftright, data_grid, affine)
    io_est = tetrapro.tetrahedral_projection(inout, c_inout, data_grid, affine)

    #Test each
    assert ud_est[0,1] != 0
    assert ud_est[1,2] != 0
    assert lr_est[0,3] != 0
    assert lr_est[1,4] != 0
    assert io_est[0,5] != 0
    assert io_est[1,6] != 0
