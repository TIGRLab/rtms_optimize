#!/usr/bin/env python
## Minimal test suite for validating tetrahedral projection algorithm
## 
## Tests implemented:
## 
##     1. Fully embedded tetrahedrons
##     2. Bordering sample rejection and resampling
##     3. Direction-specific dual membership
##     4. Single voxel exclusion test (2x2 voxels, planar, 1 voxel excluded)
##     5. Comparison to analytical solution for simple 2 voxel test
## 


import os
import numpy as np
from fieldopt import tetrapro

import mock

def gen_fully_embedded_tet(n,shape):
    '''
    Generate <n> Class 1 (fully embedded) tetrahedrons within a data grid of shape <shape> 
    Returns a list of coordinates for each node as well as vertex ID for each tetrahedron
    
    Implementational Details:
    For each tetrahedron, select a voxel i,j,k in linear ordering
    Generate a (4x3) matrix of uniformly distributed variables, where n=4 describes the number of vertices 
        and m=3 describes the i,j,k coordinates respectively. 
        
    Adjust columns of the random matrix according to voxel identity to ensure complete embedding of 
    tetrahedral vertices in voxel i,j,k
    '''

    node_ids = np.ones((n,4),dtype=np.int).cumsum().reshape((n,4)) - 1
    coord_array = np.zeros((n*4,3))
    for i in np.arange(0,n):

        #Select voxel in shape
        step_z = i // (shape[0] * shape[1])
        step_y = i // (shape[0]) - shape[2]*step_z
        step_x = i - shape[1]*step_y - shape[1]*shape[2]*step_z
        selected_vox=(step_x,step_y,step_z)

        #Generate 4 sets of random integers within the boundaries defined by voxel
        rand_coords = np.random.random(size=(4,3))

        #Modify each value generated by boundariers defined by voxel 
        rand_coords[:,0] += step_x
        rand_coords[:,1] += step_y
        rand_coords[:,2] += step_z

        coord_array[4*i,:] = rand_coords[0,:]
        coord_array[4*i+1,:] = rand_coords[1,:]
        coord_array[4*i+2,:] = rand_coords[2,:]
        coord_array[4*i+3,:] = rand_coords[3,:]
        
    return node_ids, coord_array.flatten()

def test_fully_embedded_tets_for_projection():
    '''
    Fully embedded tetrahedron test, full algorithm testing
    '''

    N = 10
    t = N**3
    affine = np.eye(4)
    data_grid = np.ones((N**3),dtype=np.int64).cumsum()
    data_grid = data_grid.reshape((N,N,N))
    data_grid = np.swapaxes(data_grid,0,2)

    node_list, coord_array = gen_fully_embedded_tet(t, data_grid.shape)
    estimates = tetrapro.tetrahedral_projection(node_list,coord_array,data_grid,affine)
    total_embedding_score = np.max(estimates,axis=0).sum()
    assert int(total_embedding_score) == t


def test_directional_membership_is_correct(): 
    '''
    Generate a 3x3x3 cube data grid then test memberships in the following order
    [-x, +x, -y, +y, -z, +z]
    '''

    #Generate test nodes and associated coordinates
    n = 6
    node_ids = np.zeros( (n,4), dtype=np.int).reshape((n,4)) 
    node_ids[:,0] = 0
    node_ids[:,1] = 1
    node_ids[:,2] = 2
    node_ids[:,3] = np.arange(3,n)

    #Fix 3 nodes
    
    
    #Generate random coordinates within central voxel of 3x3x3 cube
    coord_array = np.random.random(size=(4*n,3)) + 1

    #Perform single node shifting according to order in func docstring
    coord_array[0,0] -= 1
    coord_array[4,0] += 1
    coord_array[8,1] -= 1
    coord_array[12,1] += 1
    coord_array[16,2] -= 1
    coord_array[20,2] += 1
    coord_array = coord_array.flatten()

    #Make data grid and write values in testing region
    data_grid = np.zeros( (3,3,3), dtype=np.int64)

    #Cetral point
    data_grid[1,1,1] = 0

    #Test points
    data_grid[1,0,1] = 1
    data_grid[1,2,1] = 2
    data_grid[0,1,1] = 3
    data_grid[2,1,1] = 4
    data_grid[1,1,0] = 5
    data_grid[1,1,2] = 6

    #Basic affine
    affine = np.eye(4)

    #Run projection algorithm
    estimates = tetrapro.tetrahedral_projection(node_ids,coord_array,data_grid,affine)

    import pdb; pdb.set_trace()
    for i,e in enumerate(estimates):
        assert e[i+1] != 0
