#!/usr/bin/env python
## Minimal test suite for validating tetrahedral projection algorithm
## 
## Tests implemented:
## 
##     1. Fully embedded tetrahedrons
##     2. Bordering sample rejection and resampling
##     3. Direction-specific dual membership
##     4. Single voxel exclusion test (2x2 voxels, planar, 1 voxel excluded)
##     5. Comparison to analytical solution for simple 2 voxel test
## 


import os
import numpy as np
from fieldopt import tetrapro

import mock

def gen_fully_embedded_tet(n,shape):
    '''
    Generate <n> Class 1 (fully embedded) tetrahedrons within a data grid of shape <shape> 
    Returns a list of coordinates for each node as well as vertex ID for each tetrahedron
    
    Implementational Details:
    For each tetrahedron, select a voxel i,j,k in linear ordering
    Generate a (4x3) matrix of uniformly distributed variables, where n=4 describes the number of vertices 
        and m=3 describes the i,j,k coordinates respectively. 
        
    Adjust columns of the random matrix according to voxel identity to ensure complete embedding of 
    tetrahedral vertices in voxel i,j,k
    '''

    node_ids = np.ones((n,4),dtype=np.int).cumsum().reshape((n,4)) - 1
    coord_array = np.zeros((n*4,3))
    for i in np.arange(0,n):

        #Select voxel in shape
        step_z = i // (shape[0] * shape[1])
        step_y = i // (shape[0]) - shape[2]*step_z
        step_x = i - shape[1]*step_y - shape[1]*shape[2]*step_z
        selected_vox=(step_x,step_y,step_z)

        #Generate 4 sets of random integers within the boundaries defined by voxel
        rand_coords = np.random.random(size=(4,3))

        #Modify each value generated by boundariers defined by voxel 
        rand_coords[:,0] += step_x
        rand_coords[:,1] += step_y
        rand_coords[:,2] += step_z

        coord_array[4*i,:] = rand_coords[0,:]
        coord_array[4*i+1,:] = rand_coords[1,:]
        coord_array[4*i+2,:] = rand_coords[2,:]
        coord_array[4*i+3,:] = rand_coords[3,:]
        
    return node_ids, coord_array.flatten()

def test_fully_embedded_tets_for_projection():
    '''
    Fully embedded tetrahedron test, full algorithm testing
    '''

    N = 10
    t = N**3
    affine = np.eye(4)
    data_grid = np.ones((N**3),dtype=np.int64).cumsum()
    data_grid = data_grid.reshape((N,N,N))
    data_grid = np.swapaxes(data_grid,0,2)

    node_list, coord_array = gen_fully_embedded_tet(t, data_grid.shape)
    estimates = tetrapro.tetrahedral_projection(node_list,coord_array,data_grid,affine)
    total_embedding_score = np.max(estimates,axis=0).sum()
    assert int(total_embedding_score) == t


def test_border_cases_get_rejected():

    #Test along each dimension
    test_lowx = np.array([0,0.25,0.231])
    test_highx = np.array([1,0.13,0.003])

    test_lowy = np.array([0.23,0,0.1231])
    test_highy = np.array([0.89,1,0.001])

    test_lowz = np.array([0.101241, 0.231, 0])
    test_highz = np.array([0.789, 0.341, 1])

    vox = np.array([0,0,0])

    #Run test batch
    assert tetrapro.point_in_vox(test_lowx, vox)
    assert tetrapro.point_in_vox(test_highx, vox)

    assert tetrapro.point_in_vox(test_lowy, vox)
    assert tetrapro.point_in_vox(test_lowy, vox)

    assert tetrapro.point_in_vox(test_highz, vox)
    assert tetrapro.point_in_vox(test_highz, vox)
