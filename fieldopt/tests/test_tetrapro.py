'''
Minimal test suite for validating tetrahedral projection algorithm

Tests implemented:

    1. Fully embedded tetrahedrons
    2. Bordering sample rejection and resampling
    3. Direction-specific dual membership
    4. Single voxel exclusion test (2x2 voxels, planar, 1 voxel excluded)
    5. Comparison to analytical solution for simple 2 voxel test
'''

import numpy as np
from fieldopt import tetrapro

def gen_fully_embedded_tet(n,shape):
    '''
    Generate <n> Class 1 (fully embedded) tetrahedrons within a data grid of shape <shape> 
    Returns a list of coordinates for each node as well as vertex ID for each tetrahedron
    
    Implementational Details:
    For each tetrahedron, select a voxel i,j,k in linear ordering
    Generate a (4x3) matrix of uniformly distributed variables, where n=4 describes the number of vertices 
        and m=3 describes the i,j,k coordinates respectively. 
        
    Adjust columns of the random matrix according to voxel identity to ensure complete embedding of 
    tetrahedral vertices in voxel i,j,k
    '''

    node_ids = np.ones((n,4),dtype=np.int).cumsum().reshape((n,4))
    coord_array = np.zeros((n*4,3))
    for i in np.arange(0,n):

        #Select voxel in shape
        step_z = i // (shape[0] * shape[1])
        step_y = i // (shape[0]) - shape[2]*step_z
        step_x = i - shape[1]*step_y - shape[1]*shape[2]*step_z
        selected_vox=(step_x,step_y,step_z)

        #Generate 4 sets of random integers within the boundaries defined by voxel
        rand_coords = np.random.random(size=(4,3))

        #Modify each value generated by boundariers defined by voxel 
        rand_coords[:,0] += step_x
        rand_coords[:,1] += step_y
        rand_coords[:,2] += step_z

        coord_array[4*i,:] = rand_coords[0,:]
        coord_array[4*i+1,:] = rand_coords[1,:]
        coord_array[4*i+2,:] = rand_coords[2,:]
        coord_array[4*i+3,:] = rand_coords[3,:]
        
    return node_ids, coord_array.flatten()

#Test 1
def test_1(N=10):
    '''
    Fully embedded tetrahedron test
    '''

    affine = np.eye(4)
    data_grid = np.ones((N**3),dtype=np.int64).cumsum()
    data_grid = data_grid.reshape((N,N,N))
    data_grid = np.swapaxes(data_grid,0,2)
    node_list, coord_array = gen_fully_embedded_tet(5, data_grid.shape)

    import pdb; pdb.set_trace()
    estimates = tetrapro.tetrahedral_projection(node_list,coord_array,affine)

def main():
    test_1()

if __name__ == '__main__':
    main()
